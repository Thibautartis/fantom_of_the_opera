import re
import copy
import threading
from enum import Enum
import multiprocessing
from . import GameNode
import alphabeta.env as env

ALLOWED_PATH = env.ALLOWED_PATH
ROSE_ALLOWED_PATH = env.ROSE_ALLOWED_PATH
POWER_PERMANENT = env.POWER_PERMANENT
POWER_BEFORE = env.POWER_BEFORE
POWER_AFTER = env.POWER_AFTER
POWER_BOTH = env.POWER_BOTH

class GameTree:
  
  def newDico(self, copyDico):
    dico = GameNode.GameNode(copy.deepcopy(copyDico.pos), copy.deepcopy(copyDico.color), copyDico.sColor, copy.copy(copyDico.score), copy.copy(copyDico.used))
    return (dico)

  def findListIndex(self, color, allPos):
    for index, listPos in enumerate(allPos):
      if (listPos[0] == color):
        return index

  def findPos(self, color, allPos):
    for listPos in allPos:
      if (listPos[0] == color):
        for index, isIn in enumerate(listPos):
          if (isIn == 1):
            return index - 1

  def getLocked_path(self, listLockPos):
    locked_path = []
    for index, isIn in enumerate(listLockPos):
      if (len(locked_path) == 2):
        return locked_path
      if (isIn == 1):
        locked_path.append(index - 1)

  def getPossibleDeplacementFromPos(self, infos):
    color = infos.sColor
    cPos = self.findPos(color, infos.pos);
    
    possible = copy.deepcopy(ALLOWED_PATH if color != "rose" else ROSE_ALLOWED_PATH)
    possible = possible[cPos]
    locked_path = self.getLocked_path(infos.pos[9])

    try:
        possible.remove(locked_path[0])
    except KeyError:
        pass
    try:
        possible.remove(locked_path[1])
    except KeyError:
        pass
    return possible
      
  def chooseColor(self, infos):
    color_copy = list(infos.color)
    for color in color_copy:
      infos_copy = self.newDico(infos)
      infos_copy.sColor = color
      infos_copy.color.remove(color)
      infos_copy.parent = infos
      infos.child.append(infos_copy)

    return infos

  def blackPower(self, infos_child):
    possibleMove = self.getPossibleDeplacementFromPos(infos_child)
    cPos = self.findPos(infos_child.sColor, infos_child.pos) + 1;
    for move in possibleMove:
      for index, line in enumerate(infos_child.pos):
        if (line[move + 1] == 1):
          infos_child.pos[index][move + 1] = 0
          infos_child.pos[index][cPos] = 1
    return infos_child

  def greyPower(self, infos_child, i):
    for index, room in enumerate(infos_child.pos[8]):
      if (room == 1):
        infos_child.pos[8][index] == 0
      if (index == i):
        infos_child.pos[8][index] == 1
    infos_child.power = str(i - 1)
    return infos_child

  def violetPower(self, infos_child, i):
    if (infos_child.pos[i][0] == "violet"):
      return "violet"
    listIndex = self.findListIndex("violet", infos_child.pos)
    actualPosIndex = self.findPos(infos_child.pos[i][0], infos_child.pos)
    actualVioletIndex = self.findPos("violet", infos_child.pos)
    infos_child.pos[listIndex][actualVioletIndex + 1] = 0
    infos_child.pos[listIndex][actualPosIndex + 1] = 1
    infos_child.pos[i][actualVioletIndex + 1] = 1
    infos_child.pos[i][actualPosIndex + 1] = 1
    infos_child.power = infos_child.pos[i][0]
    return (infos_child)

  def getPath(self, i):
    values = [[0, 1],
              [1, 2],
              [2, 3],
              [0, 4],
              [4, 5],
              [5, 6],
              [6, 7],
              [3, 7],
              [4, 8],
              [7, 9],
              [8, 9]]
    return values[i]

  def bluePower(self, infos_child, i):
    locked_path = self.getLocked_path(infos_child.pos[9])
    newLock = self.getPath(i)
    if ((newLock[0] == locked_path[0] or newLock[0] == locked_path[1]) and
    (newLock[1] == locked_path[0] or newLock[1] == locked_path[1])):
      return "bleu"
    infos_child.pos[9][locked_path[0] + 1] = 0
    infos_child.pos[9][locked_path[1] + 1] = 0
    infos_child.pos[9][newLock[0] + 1] = 1
    infos_child.pos[9][newLock[1] + 1] = 1
    infos_child.power = newLock
    return infos_child

  def redPower(self, infos_child, i):
    if (i == 8):
      infos_child.score = infos_child.score - 1
      return infos_child
    if (infos_child.pos[i][11] == 0):
      return "rouge"
    infos_child.pos[i][11] = 0
    return infos_child

  def marronPower(self, infos_copy, actualPosIndex, move):
    for index in range(8):
      if infos_copy.pos[index][actualPosIndex] == 1:
        infos_copy.pos[index][actualPosIndex] = 0
        infos_copy[index][move] = 1
    return infos_copy

  def usePowerAfter(self, infos):
    if (infos.sColor in POWER_PERMANENT or infos.sColor in POWER_BEFORE):
      infos_child = self.newDico(infos)
      infos_child.parent = infos
      infos.child.append(infos_child)
      return infos
    i = 0
    while (i != 2):
      infos_child = self.newDico(infos)
      if (i == 0):
        if (infos.sColor == "gris"):
          for cpt in range(1):
            infos_child = self.newDico(infos)
            infos_child.used = True
            infos_child = self.greyPower(infos_child, cpt + 1)
            infos_child.parent = infos
            infos.child.append(infos_child)
        if (infos.sColor == "rouge"):
          for cpt in range(9):
            infos_child = self.newDico(infos)
            infos_child.used = True
            infos_child = self.redPower(infos_child, cpt)
            if (infos_child != "rouge"):
              infos_child.parent = infos
              infos.child.append(infos_child)
    #     if (infos.sColor == "bleu"):
    #       for cpt in range(1):
    #         infos_child = self.newDico(infos)
    #         infos_child.used = True
    #         infos_child = self.bluePower(infos_child, cpt)
    #         if (infos_child != "bleu"):
    #           infos_child.parent = infos
    #           infos.child.append(infos_child)
      else:
        infos_child.used = False
        infos_child.parent = infos
        infos.child.append(infos_child)
      i = i + 1

    return infos

  def usePowerBefore(self, infos):
    infos_child = self.newDico(infos)
    infos_child.parent = infos
    infos.child.append(infos_child)
    return infos
    i = 0
    while (i != 2):
      infos_child = self.newDico(infos)
      if (i == 0):
        if (infos.sColor == "violet"):
          for cpt in range(8):
            infos_child = self.newDico(infos)
            infos_child.used = True
            infos_child = self.violetPower(infos_child, cpt)
            if (infos_child != "violet"):
              infos_child.parent = infos
              infos.child.append(infos_child)
        if (infos.sColor == "gris"):
          for cpt in range(1):
              infos_child = self.newDico(infos)
              infos_child.used = True
              infos_child = self.greyPower(infos_child, cpt + 1)
              infos_child.parent = infos
              infos.child.append(infos_child)
        if (infos.sColor == "rouge"):
          for cpt in range(9):
            infos_child = self.newDico(infos)
            infos_child.used = True
            infos_child = self.redPower(infos_child, cpt)
            if (infos_child != "rouge"):
              infos_child.parent = infos
              infos.child.append(infos_child)
        if (infos.sColor == "bleu"):
          for cpt in range(1):
            infos_child = self.newDico(infos)
            infos_child.used = True
            infos_child = self.bluePower(infos_child, cpt)
          if (infos_child != "bleu"):
            infos_child.parent = infos
            infos.child.append(infos_child)
      else:
        infos_child.used = False
        infos_child.parent = infos
        infos.child.append(infos_child)
      i = i + 1
    return infos

  def moveIt(self, infos):
    possibleMove = self.getPossibleDeplacementFromPos(infos)
    for move in possibleMove:
      infos_copy = self.newDico(infos)
      listIndex = self.findListIndex(infos_copy.sColor, infos_copy.pos)
      actualPosIndex = self.findPos(infos_copy.sColor, infos_copy.pos)
      infos_copy.pos[listIndex][actualPosIndex + 1] = 0
      infos_copy.pos[listIndex][move + 1] = 1
      infos_copy.parent = infos
      infos_copy.move = move;
      infos.child.append(infos_copy)
    return infos

  def calculScream(self, infos):
    copyScream = self.newDico(infos);
    i = 1
    while (i < 11):
      cpt = 0
      for index, room in enumerate(copyScream.pos):
        if (index < 8):
          cpt = cpt + room[i]
      if (cpt > 1 and copyScream.pos[8][i] == 0):
        for index, room in enumerate(copyScream.pos):
          if (index < 8 and room[i] == 1):
            room[11] = 0
      i = i + 1

    nbSuspect = 0
    for room in copyScream.pos:
      nbSuspect = nbSuspect + room[11]
    copyScream.score = copyScream.score + 1 + nbSuspect
    return copyScream

  def calculNotScream(self, infos):
    copyNotScream = self.newDico(infos);
    i = 1
    while (i < 11):
      cpt = 0
      for index, room in enumerate(copyNotScream.pos):
        if (index < 8):
          cpt = cpt + room[i]
      if (cpt < 2 or copyNotScream.pos[8][i] == 1):
        for index, room in enumerate(copyNotScream.pos):
          if (index < 8 and room[i] == 1):
            room[11] = 0
      i = i + 1
    nbSuspect = 0
    for room in copyNotScream.pos:
      nbSuspect = nbSuspect + room[11]
    copyNotScream.score = copyNotScream.score + nbSuspect
    return copyNotScream

  def scoreCalcul(self, infos):
    copyScream = self.calculScream(infos)
    copyNotScream = self.calculNotScream(infos)

    copyScream.parent = infos
    copyNotScream.parent = infos
    infos.child.append(copyScream);
    infos.child.append(copyNotScream);
    return infos

  def doGameTree(self, root):
    root = self.chooseColor(root)
    root_children = root.child
    for nodeTuile in root_children:
      nodeTuile = self.usePowerBefore(nodeTuile)
      tuile_children = nodeTuile.child
      for nodePowerBefore in tuile_children:
        nodePowerBefore = self.moveIt(nodePowerBefore)
        before_children = nodePowerBefore.child
        for nodeMove in before_children:
          nodeMove = self.usePowerAfter(nodeMove)
          move_children = nodeMove.child
          jobs = []
          for index, nodePowerAfter in enumerate(move_children):
            out_list = list()
            if (len(nodePowerAfter.color) != 0):
              nodePowerAfter.used = False
              nodePowerAfter = (self.doGameTree(nodePowerAfter)).child
            else:
              nodePowerAfter.score = self.scoreCalcul(nodePowerAfter)
    return root
